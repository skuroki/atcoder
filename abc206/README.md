# ABC206

今回も4完。レーティングが最高に近い740まで来ていて、調子が良ければ次かその次に緑に入れそうです。一旦の目標は1000なので、まだ遠いですが。

## A

Aにしてはやや面倒な問題でした。端数切り下げの消費税計算ですね。あと3通りに結果が分かれる場合分け。

## B

```
puts (Math.sqrt(0.25 + 2 * N) - 0.5).ceil
```

d日目の夜にN円入っていることを初めて確認するとき、 `d * (d + 1) / 2 >= N` をdについて解いて、それを満たす最小のd、すなわち端数を切り上げれば良いです。dについて貯金総額は単調増加だからですね。

## C

最初からiとjの順序を考えても良い気がしますが、考えずに洗い出して最後に2で割るようにすると話がシンプルになります。

たとえば要素10個の配列にxがちょうど3つ含まれていた場合を考えると、xが絡む組み合わせは `xの要素数×x以外の要素数` なので `3 * (10 - 3) = 21` になります。

この計算を含まれている数値全てについて行えば良いです。今回はruby-jp slackで教わったtallyメソッドを初めて使いました。便利。

## D

問題文のとおりに実装すると時間が足りません。

なので、実際に変換していくとどうなるのかを最低限の計算でシミュレートしていく必要があります。

先頭と末尾からそれぞれi文字目、という組み合わせで1つづつ見ていって、その組み合わせが同じになるような変換を繰り返せばちゃんと最小手数になりますが、実際にバイト列を書き換える時間がないので、「どういう変換を行ったか」をデータとして管理する作戦です。

ここで難しいのが、1と2が3、4が5に変換されたあと、3が5に変換されると、1と2と3と4が全て5に変換されたことになる、ということです。

[1,2,3]というグループと、[4,5]というグループが、あとから合流しうるということですね。これを実現するために木構造を使いました。

これをシンプルに実装すると、偏った木になってパースに時間がかかってしまうケースを許容してしまいます。それで一度TLEになりました。

これを防ぐためには、木が合体するときに、深さが大きいほうが親になって、小さい方がぶら下がるようにすれば良いです。それでACになりました。

## E

35分間がんばりましたが、解法が整理できませんでした。1から10000でもTLEしてしまいそうなコードでした。

解法を見ました。あれはつまり、

ベン図において、AまたはBまたはCである場所の総面積＝Aの面積+Bの面積+Cの面積-AとBの共通部分の面積-BとCの共通部分の面積-CとAの共通部分の面積+3つの共通部分の面積

というような計算の一般化なわけですね。頭いい！
